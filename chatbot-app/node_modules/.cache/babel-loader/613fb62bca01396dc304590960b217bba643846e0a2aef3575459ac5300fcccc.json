{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useRef } from 'react';\nimport { generateGemini2FlashResponse, generateGeminiVisionResponse } from '../services/geminiService';\nimport { useGemini } from '../context/GeminiContext';\n// Character typing speed in milliseconds\nconst TYPING_SPEED = 5; // Faster typing speed (was 20)\n\nexport const useChat = () => {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isTyping, setIsTyping] = useState(false);\n  const [error, setError] = useState(null);\n  const {\n    selectedModel\n  } = useGemini();\n  const messageQueue = useRef(null);\n  const currentMessageRef = useRef(null);\n\n  // Function to simulate typing animation\n  const typeMessage = useCallback(fullResponse => {\n    // Create an AI message with empty content initially\n    const aiMessageId = Date.now().toString();\n    const aiMessage = {\n      id: aiMessageId,\n      content: '',\n      // Start with empty content\n      isUser: false,\n      timestamp: new Date()\n    };\n\n    // Add the empty AI message to the messages array\n    setMessages(prev => [...prev, aiMessage]);\n\n    // Set typing state to true to show typing indicator while generating the response\n    setIsTyping(true);\n    currentMessageRef.current = {\n      id: aiMessageId,\n      content: ''\n    };\n    let index = 0;\n    const responseLength = fullResponse.length;\n\n    // Function to add one character at a time\n    const typeCharacter = () => {\n      if (index < responseLength) {\n        // Get the next character\n        const nextChar = fullResponse.charAt(index);\n        index++;\n\n        // Update the message content with the next character\n        currentMessageRef.current = {\n          id: aiMessageId,\n          content: fullResponse.substring(0, index)\n        };\n\n        // Update the message in the messages array\n        setMessages(prev => prev.map(msg => msg.id === aiMessageId ? {\n          ...msg,\n          content: currentMessageRef.current.content\n        } : msg));\n\n        // Adjust typing speed based on character (reduced punctuation delay)\n        const delay = isPunctuation(nextChar) ? TYPING_SPEED * 3 : TYPING_SPEED;\n\n        // Schedule the next character\n        setTimeout(typeCharacter, delay);\n      } else {\n        // Typing complete\n        setIsTyping(false);\n        currentMessageRef.current = null;\n\n        // Check if there's a queued message to process next\n        if (messageQueue.current) {\n          const queuedMessage = messageQueue.current;\n          messageQueue.current = null;\n          typeMessage(queuedMessage);\n        }\n      }\n    };\n\n    // Start typing after a short delay to make the typing indicator visible\n    setTimeout(typeCharacter, 500);\n  }, []);\n\n  // Helper function to check if character is punctuation\n  const isPunctuation = char => {\n    return ['.', ',', '!', '?', ';', ':'].includes(char);\n  };\n  const generateResponse = useCallback(async userMessage => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      // Use the appropriate model based on selection\n      let response;\n      if (selectedModel === 'gemini-2.0-flash') {\n        response = await generateGemini2FlashResponse(userMessage);\n      } else {\n        // Default to 1.5 Flash\n        response = await generateGeminiVisionResponse(userMessage);\n      }\n      if (!response) {\n        throw new Error('No response received from the AI');\n      }\n      return response;\n    } catch (err) {\n      console.error('Error generating response:', err);\n      setError(err.message || 'Failed to generate response');\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [selectedModel]);\n  const sendMessage = useCallback(async content => {\n    if (!content.trim()) return;\n\n    // Clear any existing errors\n    setError(null);\n\n    // Add user message\n    const userMessage = {\n      id: Date.now().toString(),\n      content: content.trim(),\n      isUser: true,\n      timestamp: new Date()\n    };\n    setMessages(prev => [...prev, userMessage]);\n\n    // Generate AI response\n    const response = await generateResponse(content);\n    if (response) {\n      // If already typing, queue this message\n      if (isTyping) {\n        messageQueue.current = response;\n      } else {\n        // Start typing animation for this message\n        typeMessage(response);\n      }\n    }\n  }, [generateResponse, isTyping, typeMessage]);\n  const clearMessages = useCallback(() => {\n    setMessages([]);\n    setError(null);\n    messageQueue.current = null;\n    currentMessageRef.current = null;\n  }, []);\n  return {\n    messages,\n    isLoading,\n    isTyping,\n    error,\n    sendMessage,\n    clearMessages\n  };\n};\n_s(useChat, \"BbnrBV2tuHRHHr82XAwhOn4s1QQ=\", false, function () {\n  return [useGemini];\n});\nexport default useChat;","map":{"version":3,"names":["useState","useCallback","useRef","generateGemini2FlashResponse","generateGeminiVisionResponse","useGemini","TYPING_SPEED","useChat","_s","messages","setMessages","isLoading","setIsLoading","isTyping","setIsTyping","error","setError","selectedModel","messageQueue","currentMessageRef","typeMessage","fullResponse","aiMessageId","Date","now","toString","aiMessage","id","content","isUser","timestamp","prev","current","index","responseLength","length","typeCharacter","nextChar","charAt","substring","map","msg","delay","isPunctuation","setTimeout","queuedMessage","char","includes","generateResponse","userMessage","response","Error","err","console","message","sendMessage","trim","clearMessages"],"sources":["C:/Users/alamk/OneDrive/Desktop/Chatbot/chatbot-app/src/hooks/useChat.ts"],"sourcesContent":["import { useState, useCallback, useRef } from 'react';\r\nimport { generateGemini2FlashResponse, generateGeminiVisionResponse } from '../services/geminiService';\r\nimport { useGemini } from '../context/GeminiContext';\r\n\r\ninterface Message {\r\n  id: string;\r\n  content: string;\r\n  isUser: boolean;\r\n  timestamp: Date;\r\n}\r\n\r\n// Character typing speed in milliseconds\r\nconst TYPING_SPEED = 5; // Faster typing speed (was 20)\r\n\r\nexport const useChat = () => {\r\n  const [messages, setMessages] = useState<Message[]>([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [isTyping, setIsTyping] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const { selectedModel } = useGemini();\r\n  const messageQueue = useRef<string | null>(null);\r\n  const currentMessageRef = useRef<{id: string, content: string} | null>(null);\r\n\r\n  // Function to simulate typing animation\r\n  const typeMessage = useCallback((fullResponse: string) => {\r\n    // Create an AI message with empty content initially\r\n    const aiMessageId = Date.now().toString();\r\n    const aiMessage: Message = {\r\n      id: aiMessageId,\r\n      content: '', // Start with empty content\r\n      isUser: false,\r\n      timestamp: new Date()\r\n    };\r\n    \r\n    // Add the empty AI message to the messages array\r\n    setMessages(prev => [...prev, aiMessage]);\r\n    \r\n    // Set typing state to true to show typing indicator while generating the response\r\n    setIsTyping(true);\r\n    currentMessageRef.current = { id: aiMessageId, content: '' };\r\n    \r\n    let index = 0;\r\n    const responseLength = fullResponse.length;\r\n    \r\n    // Function to add one character at a time\r\n    const typeCharacter = () => {\r\n      if (index < responseLength) {\r\n        // Get the next character\r\n        const nextChar = fullResponse.charAt(index);\r\n        index++;\r\n        \r\n        // Update the message content with the next character\r\n        currentMessageRef.current = {\r\n          id: aiMessageId,\r\n          content: fullResponse.substring(0, index)\r\n        };\r\n        \r\n        // Update the message in the messages array\r\n        setMessages(prev => \r\n          prev.map(msg => \r\n            msg.id === aiMessageId \r\n              ? { ...msg, content: currentMessageRef.current!.content } \r\n              : msg\r\n          )\r\n        );\r\n        \r\n        // Adjust typing speed based on character (reduced punctuation delay)\r\n        const delay = isPunctuation(nextChar) ? TYPING_SPEED * 3 : TYPING_SPEED;\r\n        \r\n        // Schedule the next character\r\n        setTimeout(typeCharacter, delay);\r\n      } else {\r\n        // Typing complete\r\n        setIsTyping(false);\r\n        currentMessageRef.current = null;\r\n        \r\n        // Check if there's a queued message to process next\r\n        if (messageQueue.current) {\r\n          const queuedMessage = messageQueue.current;\r\n          messageQueue.current = null;\r\n          typeMessage(queuedMessage);\r\n        }\r\n      }\r\n    };\r\n    \r\n    // Start typing after a short delay to make the typing indicator visible\r\n    setTimeout(typeCharacter, 500);\r\n  }, []);\r\n  \r\n  // Helper function to check if character is punctuation\r\n  const isPunctuation = (char: string): boolean => {\r\n    return ['.', ',', '!', '?', ';', ':'].includes(char);\r\n  };\r\n\r\n  const generateResponse = useCallback(async (userMessage: string) => {\r\n    setIsLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      // Use the appropriate model based on selection\r\n      let response: string;\r\n      \r\n      if (selectedModel === 'gemini-2.0-flash') {\r\n        response = await generateGemini2FlashResponse(userMessage);\r\n      } else {\r\n        // Default to 1.5 Flash\r\n        response = await generateGeminiVisionResponse(userMessage);\r\n      }\r\n\r\n      if (!response) {\r\n        throw new Error('No response received from the AI');\r\n      }\r\n\r\n      return response;\r\n    } catch (err: any) {\r\n      console.error('Error generating response:', err);\r\n      setError(err.message || 'Failed to generate response');\r\n      return null;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [selectedModel]);\r\n\r\n  const sendMessage = useCallback(async (content: string) => {\r\n    if (!content.trim()) return;\r\n\r\n    // Clear any existing errors\r\n    setError(null);\r\n\r\n    // Add user message\r\n    const userMessage: Message = {\r\n      id: Date.now().toString(),\r\n      content: content.trim(),\r\n      isUser: true,\r\n      timestamp: new Date()\r\n    };\r\n    setMessages(prev => [...prev, userMessage]);\r\n\r\n    // Generate AI response\r\n    const response = await generateResponse(content);\r\n    \r\n    if (response) {\r\n      // If already typing, queue this message\r\n      if (isTyping) {\r\n        messageQueue.current = response;\r\n      } else {\r\n        // Start typing animation for this message\r\n        typeMessage(response);\r\n      }\r\n    }\r\n  }, [generateResponse, isTyping, typeMessage]);\r\n\r\n  const clearMessages = useCallback(() => {\r\n    setMessages([]);\r\n    setError(null);\r\n    messageQueue.current = null;\r\n    currentMessageRef.current = null;\r\n  }, []);\r\n\r\n  return {\r\n    messages,\r\n    isLoading,\r\n    isTyping,\r\n    error,\r\n    sendMessage,\r\n    clearMessages\r\n  };\r\n};\r\n\r\nexport default useChat; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}