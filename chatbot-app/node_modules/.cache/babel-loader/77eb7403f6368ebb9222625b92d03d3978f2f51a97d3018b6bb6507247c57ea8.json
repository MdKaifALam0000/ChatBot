{"ast":null,"code":"import React,{createContext,useState,useContext}from'react';import{jsx as _jsx}from\"react/jsx-runtime\";const defaultValue={apiKey:'',isValidKey:false,isLoading:false,error:null,setApiKey:()=>{},validateKey:async()=>false,resetError:()=>{}};export const GeminiContext=/*#__PURE__*/createContext(defaultValue);export const useGemini=()=>{const context=useContext(GeminiContext);if(!context){throw new Error('useGemini must be used within a GeminiProvider');}return context;};export const GeminiProvider=_ref=>{let{children}=_ref;// Hardcode the API key and consider it valid\nconst[apiKey]=useState(\"AIzaSyAsdXIijrxubtnxPX6pSfXhwZnVc3N6HBw\");const[isValidKey,setIsValidKey]=useState(true);const[isLoading,setIsLoading]=useState(false);const[error,setError]=useState(null);// Keep the validateKey function for API consistency, but simplify it\nconst validateKey=async()=>{return true;// Always return true since we're using a hardcoded key\n};// Simple setter to maintain the interface but it won't actually change the key\nconst setApiKey=key=>{// No-op - we're using the hardcoded key only\nconsole.log(\"API key changes are disabled - using hardcoded key\");};const resetError=()=>{setError(null);};return/*#__PURE__*/_jsx(GeminiContext.Provider,{value:{apiKey,isValidKey,isLoading,error,setApiKey,validateKey,resetError},children:children});};","map":{"version":3,"names":["React","createContext","useState","useContext","jsx","_jsx","defaultValue","apiKey","isValidKey","isLoading","error","setApiKey","validateKey","resetError","GeminiContext","useGemini","context","Error","GeminiProvider","_ref","children","setIsValidKey","setIsLoading","setError","key","console","log","Provider","value"],"sources":["C:/Users/alamk/OneDrive/Desktop/Chatbot/chatbot-app/src/context/GeminiContext.tsx"],"sourcesContent":["import React, { createContext, useState, useEffect, ReactNode, useContext } from 'react';\r\nimport { validateGeminiKey } from '../services/geminiService';\r\n\r\ninterface GeminiContextType {\r\n  apiKey: string;\r\n  isValidKey: boolean;\r\n  isLoading: boolean;\r\n  error: string | null;\r\n  setApiKey: (key: string) => void;\r\n  validateKey: () => Promise<boolean>;\r\n  resetError: () => void;\r\n}\r\n\r\nconst defaultValue: GeminiContextType = {\r\n  apiKey: '',\r\n  isValidKey: false,\r\n  isLoading: false,\r\n  error: null,\r\n  setApiKey: () => {},\r\n  validateKey: async () => false,\r\n  resetError: () => {},\r\n};\r\n\r\nexport const GeminiContext = createContext<GeminiContextType>(defaultValue);\r\n\r\ninterface GeminiProviderProps {\r\n  children: ReactNode;\r\n}\r\n\r\nexport const useGemini = () => {\r\n  const context = useContext(GeminiContext);\r\n  \r\n  if (!context) {\r\n    throw new Error('useGemini must be used within a GeminiProvider');\r\n  }\r\n  \r\n  return context;\r\n};\r\n\r\nexport const GeminiProvider: React.FC<GeminiProviderProps> = ({ children }) => {\r\n  // Hardcode the API key and consider it valid\r\n  const [apiKey] = useState<string>(\"AIzaSyAsdXIijrxubtnxPX6pSfXhwZnVc3N6HBw\");\r\n  const [isValidKey, setIsValidKey] = useState<boolean>(true);\r\n  const [isLoading, setIsLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  // Keep the validateKey function for API consistency, but simplify it\r\n  const validateKey = async (): Promise<boolean> => {\r\n    return true; // Always return true since we're using a hardcoded key\r\n  };\r\n\r\n  // Simple setter to maintain the interface but it won't actually change the key\r\n  const setApiKey = (key: string) => {\r\n    // No-op - we're using the hardcoded key only\r\n    console.log(\"API key changes are disabled - using hardcoded key\");\r\n  };\r\n\r\n  const resetError = () => {\r\n    setError(null);\r\n  };\r\n\r\n  return (\r\n    <GeminiContext.Provider\r\n      value={{\r\n        apiKey,\r\n        isValidKey,\r\n        isLoading,\r\n        error,\r\n        setApiKey,\r\n        validateKey,\r\n        resetError,\r\n      }}\r\n    >\r\n      {children}\r\n    </GeminiContext.Provider>\r\n  );\r\n}; "],"mappings":"AAAA,MAAO,CAAAA,KAAK,EAAIC,aAAa,CAAEC,QAAQ,CAAwBC,UAAU,KAAQ,OAAO,CAAC,OAAAC,GAAA,IAAAC,IAAA,yBAazF,KAAM,CAAAC,YAA+B,CAAG,CACtCC,MAAM,CAAE,EAAE,CACVC,UAAU,CAAE,KAAK,CACjBC,SAAS,CAAE,KAAK,CAChBC,KAAK,CAAE,IAAI,CACXC,SAAS,CAAEA,CAAA,GAAM,CAAC,CAAC,CACnBC,WAAW,CAAE,KAAAA,CAAA,GAAY,KAAK,CAC9BC,UAAU,CAAEA,CAAA,GAAM,CAAC,CACrB,CAAC,CAED,MAAO,MAAM,CAAAC,aAAa,cAAGb,aAAa,CAAoBK,YAAY,CAAC,CAM3E,MAAO,MAAM,CAAAS,SAAS,CAAGA,CAAA,GAAM,CAC7B,KAAM,CAAAC,OAAO,CAAGb,UAAU,CAACW,aAAa,CAAC,CAEzC,GAAI,CAACE,OAAO,CAAE,CACZ,KAAM,IAAI,CAAAC,KAAK,CAAC,gDAAgD,CAAC,CACnE,CAEA,MAAO,CAAAD,OAAO,CAChB,CAAC,CAED,MAAO,MAAM,CAAAE,cAA6C,CAAGC,IAAA,EAAkB,IAAjB,CAAEC,QAAS,CAAC,CAAAD,IAAA,CACxE;AACA,KAAM,CAACZ,MAAM,CAAC,CAAGL,QAAQ,CAAS,yCAAyC,CAAC,CAC5E,KAAM,CAACM,UAAU,CAAEa,aAAa,CAAC,CAAGnB,QAAQ,CAAU,IAAI,CAAC,CAC3D,KAAM,CAACO,SAAS,CAAEa,YAAY,CAAC,CAAGpB,QAAQ,CAAU,KAAK,CAAC,CAC1D,KAAM,CAACQ,KAAK,CAAEa,QAAQ,CAAC,CAAGrB,QAAQ,CAAgB,IAAI,CAAC,CAEvD;AACA,KAAM,CAAAU,WAAW,CAAG,KAAAA,CAAA,GAA8B,CAChD,MAAO,KAAI,CAAE;AACf,CAAC,CAED;AACA,KAAM,CAAAD,SAAS,CAAIa,GAAW,EAAK,CACjC;AACAC,OAAO,CAACC,GAAG,CAAC,oDAAoD,CAAC,CACnE,CAAC,CAED,KAAM,CAAAb,UAAU,CAAGA,CAAA,GAAM,CACvBU,QAAQ,CAAC,IAAI,CAAC,CAChB,CAAC,CAED,mBACElB,IAAA,CAACS,aAAa,CAACa,QAAQ,EACrBC,KAAK,CAAE,CACLrB,MAAM,CACNC,UAAU,CACVC,SAAS,CACTC,KAAK,CACLC,SAAS,CACTC,WAAW,CACXC,UACF,CAAE,CAAAO,QAAA,CAEDA,QAAQ,CACa,CAAC,CAE7B,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}