{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback } from 'react';\nimport { generateGemini2FlashResponse, generateGeminiVisionResponse } from '../services/geminiService';\nimport { useGemini } from '../context/GeminiContext';\nexport const useChat = () => {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isTyping, setIsTyping] = useState(false);\n  const [error, setError] = useState(null);\n  const {\n    selectedModel\n  } = useGemini();\n  const generateResponse = useCallback(async userMessage => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      // Use the appropriate model based on selection\n      let response;\n      if (selectedModel === 'gemini-2.0-flash') {\n        response = await generateGemini2FlashResponse(userMessage);\n      } else {\n        // Default to 1.5 Flash\n        response = await generateGeminiVisionResponse(userMessage);\n      }\n      if (!response) {\n        throw new Error('No response received from the AI');\n      }\n      return response;\n    } catch (err) {\n      console.error('Error generating response:', err);\n      setError(err.message || 'Failed to generate response');\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [selectedModel]);\n  const sendMessage = useCallback(async content => {\n    if (!content.trim()) return;\n\n    // Clear any existing errors\n    setError(null);\n\n    // Add user message\n    const userMessage = {\n      id: Date.now().toString(),\n      content: content.trim(),\n      isUser: true,\n      timestamp: new Date()\n    };\n    setMessages(prev => [...prev, userMessage]);\n\n    // Generate and add AI response\n    const response = await generateResponse(content);\n    if (response) {\n      const aiMessage = {\n        id: Date.now().toString(),\n        content: response,\n        isUser: false,\n        timestamp: new Date()\n      };\n      setMessages(prev => [...prev, aiMessage]);\n    }\n  }, [generateResponse]);\n  const clearMessages = useCallback(() => {\n    setMessages([]);\n    setError(null);\n  }, []);\n  return {\n    messages,\n    isLoading,\n    isTyping,\n    error,\n    sendMessage,\n    clearMessages\n  };\n};\n_s(useChat, \"YKKB/IgeIvLUTtPJdlxDevcyKa8=\", false, function () {\n  return [useGemini];\n});\nexport default useChat;","map":{"version":3,"names":["useState","useCallback","generateGemini2FlashResponse","generateGeminiVisionResponse","useGemini","useChat","_s","messages","setMessages","isLoading","setIsLoading","isTyping","setIsTyping","error","setError","selectedModel","generateResponse","userMessage","response","Error","err","console","message","sendMessage","content","trim","id","Date","now","toString","isUser","timestamp","prev","aiMessage","clearMessages"],"sources":["C:/Users/alamk/OneDrive/Desktop/Chatbot/chatbot-app/src/hooks/useChat.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\r\nimport { generateGemini2FlashResponse, generateGeminiVisionResponse } from '../services/geminiService';\r\nimport { useGemini } from '../context/GeminiContext';\r\n\r\ninterface Message {\r\n  id: string;\r\n  content: string;\r\n  isUser: boolean;\r\n  timestamp: Date;\r\n}\r\n\r\nexport const useChat = () => {\r\n  const [messages, setMessages] = useState<Message[]>([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [isTyping, setIsTyping] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const { selectedModel } = useGemini();\r\n\r\n  const generateResponse = useCallback(async (userMessage: string) => {\r\n    setIsLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      // Use the appropriate model based on selection\r\n      let response: string;\r\n      \r\n      if (selectedModel === 'gemini-2.0-flash') {\r\n        response = await generateGemini2FlashResponse(userMessage);\r\n      } else {\r\n        // Default to 1.5 Flash\r\n        response = await generateGeminiVisionResponse(userMessage);\r\n      }\r\n\r\n      if (!response) {\r\n        throw new Error('No response received from the AI');\r\n      }\r\n\r\n      return response;\r\n    } catch (err: any) {\r\n      console.error('Error generating response:', err);\r\n      setError(err.message || 'Failed to generate response');\r\n      return null;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [selectedModel]);\r\n\r\n  const sendMessage = useCallback(async (content: string) => {\r\n    if (!content.trim()) return;\r\n\r\n    // Clear any existing errors\r\n    setError(null);\r\n\r\n    // Add user message\r\n    const userMessage: Message = {\r\n      id: Date.now().toString(),\r\n      content: content.trim(),\r\n      isUser: true,\r\n      timestamp: new Date()\r\n    };\r\n    setMessages(prev => [...prev, userMessage]);\r\n\r\n    // Generate and add AI response\r\n    const response = await generateResponse(content);\r\n    if (response) {\r\n      const aiMessage: Message = {\r\n        id: Date.now().toString(),\r\n        content: response,\r\n        isUser: false,\r\n        timestamp: new Date()\r\n      };\r\n      setMessages(prev => [...prev, aiMessage]);\r\n    }\r\n  }, [generateResponse]);\r\n\r\n  const clearMessages = useCallback(() => {\r\n    setMessages([]);\r\n    setError(null);\r\n  }, []);\r\n\r\n  return {\r\n    messages,\r\n    isLoading,\r\n    isTyping,\r\n    error,\r\n    sendMessage,\r\n    clearMessages\r\n  };\r\n};\r\n\r\nexport default useChat; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}