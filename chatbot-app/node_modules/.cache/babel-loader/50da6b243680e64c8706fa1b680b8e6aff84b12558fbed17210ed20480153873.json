{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useCallback, useEffect } from 'react';\nimport { generateChatResponse } from '../services/geminiService';\nimport { useGemini } from '../contexts/GeminiContext';\nexport const useChat = () => {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const {\n    apiKey,\n    isKeyValid\n  } = useGemini();\n\n  // Clear error when API key or validity changes\n  useEffect(() => {\n    setError(null);\n  }, [apiKey, isKeyValid]);\n  const generateResponse = useCallback(async userMessage => {\n    if (!apiKey || !isKeyValid) {\n      setError('Please set up a valid Gemini API key in settings');\n      return null;\n    }\n    setIsLoading(true);\n    setError(null);\n    try {\n      // Include the new user message in the context\n      const chatHistory = [...messages];\n\n      // Add the current message to history\n      const response = await generateChatResponse([...chatHistory, {\n        content: userMessage,\n        isUser: true\n      }], apiKey);\n      if (!response) {\n        throw new Error('No response received from the AI');\n      }\n      return response;\n    } catch (err) {\n      console.error('Error generating response:', err);\n      setError(err.message || 'Failed to generate response');\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [apiKey, isKeyValid, messages]);\n  const sendMessage = useCallback(async content => {\n    if (!content.trim()) return;\n\n    // Clear any existing errors\n    setError(null);\n\n    // Add user message\n    const userMessage = {\n      id: Date.now().toString(),\n      content: content.trim(),\n      isUser: true,\n      timestamp: new Date()\n    };\n    setMessages(prev => [...prev, userMessage]);\n\n    // Generate and add AI response\n    const response = await generateResponse(content);\n    if (response) {\n      const aiMessage = {\n        content: response,\n        isUser: false,\n        timestamp: new Date()\n      };\n      setMessages(prev => [...prev, aiMessage]);\n    }\n  }, [generateResponse]);\n  const clearMessages = useCallback(() => {\n    setMessages([]);\n    setError(null);\n  }, []);\n  return {\n    messages,\n    isLoading,\n    error,\n    sendMessage,\n    clearMessages\n  };\n};\n_s(useChat, \"cFqsTaUfBpJmYAQcdZmxbe7a1MQ=\", false, function () {\n  return [useGemini];\n});\nexport default useChat;","map":{"version":3,"names":["useState","useCallback","useEffect","generateChatResponse","useGemini","useChat","_s","messages","setMessages","isLoading","setIsLoading","error","setError","apiKey","isKeyValid","generateResponse","userMessage","chatHistory","response","content","isUser","Error","err","console","message","sendMessage","trim","id","Date","now","toString","timestamp","prev","aiMessage","clearMessages"],"sources":["C:/Users/alamk/OneDrive/Desktop/Chatbot/chatbot-app/src/hooks/useChat.ts"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\r\nimport { generateChatResponse } from '../services/geminiService';\r\nimport { useGemini } from '../contexts/GeminiContext';\r\n\r\ninterface Message {\r\n  id: string;\r\n  content: string;\r\n  isUser: boolean;\r\n  timestamp: Date;\r\n}\r\n\r\nexport const useChat = () => {\r\n  const [messages, setMessages] = useState<Message[]>([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const { apiKey, isKeyValid } = useGemini();\r\n\r\n  // Clear error when API key or validity changes\r\n  useEffect(() => {\r\n    setError(null);\r\n  }, [apiKey, isKeyValid]);\r\n\r\n  const generateResponse = useCallback(async (userMessage: string) => {\r\n    if (!apiKey || !isKeyValid) {\r\n      setError('Please set up a valid Gemini API key in settings');\r\n      return null;\r\n    }\r\n\r\n    setIsLoading(true);\r\n    setError(null);\r\n\r\n    try {\r\n      // Include the new user message in the context\r\n      const chatHistory = [...messages];\r\n      \r\n      // Add the current message to history\r\n      const response = await generateChatResponse(\r\n        [...chatHistory, { content: userMessage, isUser: true }],\r\n        apiKey\r\n      );\r\n\r\n      if (!response) {\r\n        throw new Error('No response received from the AI');\r\n      }\r\n\r\n      return response;\r\n    } catch (err: any) {\r\n      console.error('Error generating response:', err);\r\n      setError(err.message || 'Failed to generate response');\r\n      return null;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [apiKey, isKeyValid, messages]);\r\n\r\n  const sendMessage = useCallback(async (content: string) => {\r\n    if (!content.trim()) return;\r\n\r\n    // Clear any existing errors\r\n    setError(null);\r\n\r\n    // Add user message\r\n    const userMessage: Message = {\r\n      id: Date.now().toString(),\r\n      content: content.trim(),\r\n      isUser: true,\r\n      timestamp: new Date()\r\n    };\r\n    setMessages(prev => [...prev, userMessage]);\r\n\r\n    // Generate and add AI response\r\n    const response = await generateResponse(content);\r\n    if (response) {\r\n      const aiMessage: Message = {\r\n        content: response,\r\n        isUser: false,\r\n        timestamp: new Date()\r\n      };\r\n      setMessages(prev => [...prev, aiMessage]);\r\n    }\r\n  }, [generateResponse]);\r\n\r\n  const clearMessages = useCallback(() => {\r\n    setMessages([]);\r\n    setError(null);\r\n  }, []);\r\n\r\n  return {\r\n    messages,\r\n    isLoading,\r\n    error,\r\n    sendMessage,\r\n    clearMessages\r\n  };\r\n};\r\n\r\nexport default useChat; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}